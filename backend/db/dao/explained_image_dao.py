from typing import List, Optional


from fastapi import Depends
from sqlalchemy import select, delete, update, UUID
from sqlalchemy.ext.asyncio import AsyncSession
from starlette.responses import Response

from backend.core.assistant.llm_engine.gpt_engine import GPTEngine
from backend.db.dependencies import get_db_session
from backend.db.models.echo_model import EchoModel
from backend.db.models.explained_image_model import ExplainedImageModel
from backend.models.explained_image import ExplainedImage
from backend.web.api.images.dtos.explained_image_dto import UpdateExplainedImageDTO


class ExplainedImageDAO:
    """Class for accessing the explained_images table."""

    def __init__(self, session: AsyncSession = Depends(get_db_session)):
        self.session = session

    async def create_explained_image(
        self,
        image: str,
        title: str,
        date: str,
        latitude: float,
        longitude: float,
        altitude: int,
        location: str,
        direction: str | None,
        additional_comment: str,
        additional_comment_vector: List[float],
        echo: EchoModel,
    ) -> None:
        """
        Add single explained image to session.

        :param echo_dao: Access to the echo table.
        :param image: URL or identifier of the image.
        :param title: Title of the image.
        :param date: Optional date associated with the image.
        :param latitude: Optional latitude where the image was taken.
        :param longitude: Optional longitude where the image was taken.
        :param altitude: Optional altitude where the image was taken.
        :param location: Optional location information.
        :param direction: Optional direction information.
        :param additional_comment: Optional comment generated by AI initially.
        :param additional_comment_vector: Optional vector representation of the AI comment.
        :param echo: Echo model.
        """
        explained_image = ExplainedImageModel(
            image="https://i.redd.it/ojna3hgcsfa51.jpg",
            title=title,
            date=date,
            latitude=latitude,
            longitude=longitude,
            altitude=altitude,
            location=location,
            direction=direction,
            additional_comment=additional_comment,
            additional_comment_vector=additional_comment_vector,
            echo_id=echo.id,
            echo=echo,
        )
        self.session.add(explained_image)

    async def get_all_explained_images(
        self,
    ) -> List[ExplainedImageModel]:
        """
        Get all explained image models with limit/offset pagination.

        :param limit: limit of explained images.
        :param offset: offset of explained images.
        :return: stream of explained images.
        """
        raw_explained_images = await self.session.execute(
            select(ExplainedImageModel)
        )

        return list(raw_explained_images.scalars().fetchall())

    async def get_all_explained_images_by_echo_id(
        self,
        echo_id: UUID,
    ) -> List[ExplainedImageModel]:
        """
        Get all explained image models with limit/offset pagination.

        :param echo_id: ID of the echo.
        :param limit: limit of explained images.
        :param offset: offset of explained images.
        :return: stream of explained images.
        """
        raw_explained_images = await self.session.execute(
            select(ExplainedImageModel).where(ExplainedImageModel.echo_id == echo_id)
        )

        return list(raw_explained_images.scalars().fetchall())

    async def get_explained_image_by_id(
        self,
        id: UUID,
    ) -> ExplainedImageModel:
        """
        Get specific explained image model.

        :param id: ID of the image.
        :return: explained image model.
        """
        query = select(ExplainedImageModel).where(ExplainedImageModel.id == id)
        row = await self.session.execute(query)
        return row.scalars().first()

    async def delete_explained_image_by_id(
        self,
        id: UUID,
    ) -> Response:
        """
        Delete specific explained image model.
        :param id: ID of the image.
        :return: explained image model.
        """
        query = delete(ExplainedImageModel).where(ExplainedImageModel.id == id)
        row = await self.session.execute(query)
        return Response()

    async def update_explained_image_by_id(self, image: UpdateExplainedImageDTO):
        """
        Update specific explained image model.
        :param id: ID of the image.
        :param image: ExplainedImage object.
        :return: explained image model.
        """

        original_image = await self.get_explained_image_by_id(image.id)
        if image.additional_comment == original_image.additional_comment:
            vector = original_image.additional_comment_vector
        else:
            gpt_engine = GPTEngine("gpt-3.5-turbo", self)
            vector = gpt_engine.embeddings_engine.embed_query(image.additional_comment)
        query = update(ExplainedImageModel).where(ExplainedImageModel.id ==
                                                  image.id).values(
            image=image.image,
            title=image.title,
            date=image.date,
            latitude=image.latitude,
            longitude=image.longitude,
            altitude=image.altitude,
            location=image.location,
            direction=image.direction,
            additional_comment=image.additional_comment,
            additional_comment_vector=vector,
        )
        row = await self.session.execute(query)

    async def filter(
        self,
        image: Optional[str] = None,
        comment: Optional[str] = None,
    ) -> List[ExplainedImageModel]:
        """
        Get specific explained image model.

        :param image: URL or identifier of the image.
        :param comment: Comment associated with the image.
        :return: explained image models.
        """
        query = select(ExplainedImageModel)
        if image:
            query = query.where(ExplainedImageModel.image == image)
        if comment:
            query = query.where(ExplainedImageModel.title == comment)
        rows = await self.session.execute(query)
        return list(rows.scalars().fetchall())

    async def similarity_search(
        self,
        vector: List[float],
        limit: int = 1,
    ) -> List[ExplainedImageModel]:
        """
        Get similar explained image models.

        :param vector: Vector representation of the image.
        :param limit: limit of explained images.
        :return: explained image models.
        """
        result = await self.session.scalars(
            select(ExplainedImageModel).order_by(
                ExplainedImageModel.additional_comment_vector.l2_distance(vector)
            ),
        )
        return result.fetchmany(limit)
